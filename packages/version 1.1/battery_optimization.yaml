###############################################################################
# Package: battery_optimization.yaml
# Purpose:
#   Huawei Luna2000 battery optimizer:
#   - Charge when cheap / solar surplus
#   - Discharge when price high or peak risk
#   - Respect reserve SoC and peak-power limits
#   - Integrate with Nordpool cheapest hours calendar
#
# Depends on:
#   - sensor.battery_state_of_capacity
#   - sensor.solar_power_production
#   - sensor.huawei_battery_import_export
#   - sensor.nordpool_kwh_se3_sek_2_095_025
#   - sensor.total_power_usage
#   - input_number.peak_power_limit       (from Peak Shaving package)
#   - binary_sensor.electricity_cheapest_now
#   - input_number.battery_cheapest_hours_target_soc
#   - Huawei Solar services:
#       huawei_solar.forcible_charge_soc
#       huawei_solar.forcible_discharge_soc
#       huawei_solar.stop_forcible_charge
###############################################################################

###############################################################################
# INPUT NUMBERS / INPUT BOOLEANS
#   Shared helpers now live in packages/battery_shared_helpers.yaml
###############################################################################
# TEMPLATE SENSORS & BINARY SENSORS – Decision helpers
###############################################################################
template:
  - sensor:
      #########################################################################
      # sensor.battery_effective_peak_limit
      # Peak limit adjusted for night rule (22:00–06:00 counts as 50 %)
      #########################################################################
      - name: "Battery Effective Peak Limit"
        unique_id: battery_effective_peak_limit
        unit_of_measurement: "kW"
        state: >
          {% set base = states('input_number.peak_power_limit') | float(0) %}
          {% set hour = now().hour %}
          {% set factor = 0.5 if hour >= 22 or hour < 6 else 1.0 %}
          {{ (base * factor) | round(2) }}

      #########################################################################
      # sensor.battery_current_price_sek
      #########################################################################
      - name: "Battery Current Price (SEK)"
        unique_id: battery_current_price_sek
        unit_of_measurement: "SEK/kWh"
        state: >
          {{ states('sensor.nordpool_kwh_se3_sek_2_095_025') | float(0) }}

      #########################################################################
      # sensor.battery_estimated_available_discharge_power
      # Simple proxy: positive = discharge, negative = charge
      #########################################################################
      - name: "Battery Estimated Available Discharge Power"
        unique_id: battery_estimated_available_discharge_power
        unit_of_measurement: "kW"
        state: >
          {{ states('sensor.huawei_battery_import_export') | float(0) | round(2) }}

  - binary_sensor:
      #########################################################################
      # binary_sensor.battery_in_cheap_price_window
      #########################################################################
      - name: "Battery – In cheap price window"
        unique_id: battery_in_cheap_price_window
        state: >
          {% set price = states('sensor.nordpool_kwh_se3_sek_2_095_025') | float(0) %}
          {% set low  = states('input_number.battery_low_price_threshold') | float(0) %}
          {{ price > 0 and low > 0 and price <= low }}

      #########################################################################
      # binary_sensor.battery_in_expensive_price_window
      #########################################################################
      - name: "Battery – In expensive price window"
        unique_id: battery_in_expensive_price_window
        state: >
          {% set price = states('sensor.nordpool_kwh_se3_sek_2_095_025') | float(0) %}
          {% set high = states('input_number.battery_high_price_threshold') | float(0) %}
          {{ price > 0 and high > 0 and price >= high }}

      #########################################################################
      # binary_sensor.battery_peak_risk_now
      # Uses total_power_usage vs effective peak limit
      #########################################################################
      - name: "Battery – Peak risk now"
        unique_id: battery_peak_risk_now
        state: >
          {% set load = states('sensor.total_power_usage') | float(0) %}
          {% set limit = states('sensor.battery_effective_peak_limit') | float(0) %}
          {{ load >= limit and limit > 0 }}

      #########################################################################
      # binary_sensor.battery_solar_surplus_now
      # Simple heuristic: solar production > 500 W and import_export_power >= 0
      #########################################################################
      - name: "Battery – Solar surplus now"
        unique_id: battery_solar_surplus_now
        state: >
          {% set solar = states('sensor.solar_power_production') | float(0) %}
          {% set flow  = states('sensor.import_export_power') | float(0) %}
          {{ solar > 500 and flow >= 0 }}

      #########################################################################
      # binary_sensor.battery_can_grid_charge_now
      # Conditions:
      #   - automation + grid charge allowed
      #   - cheap price OR cheapest-hour active
      #   - SoC below target / max_grid_charge_soc
      #   - NOT peak risk
      #########################################################################
      - name: "Battery – Can grid charge now"
        unique_id: battery_can_grid_charge_now
        state: >
          {% set enabled       = is_state('input_boolean.battery_automation_enabled', 'on') %}
          {% set allow_grid    = is_state('input_boolean.battery_allow_grid_charge', 'on') %}
          {% set cheap_price   = is_state('binary_sensor.battery_in_cheap_price_window', 'on') %}
          {% set cheapest_hour = is_state('binary_sensor.electricity_cheapest_now', 'on') %}
          {% set soc           = states('sensor.battery_state_of_capacity') | float(0) %}
          {% set target_soc    = states('input_number.battery_cheapest_hours_target_soc') | float(0) %}
          {% set max_soc       = states('input_number.battery_max_grid_charge_soc') | float(100) %}
          {% set peak_risk     = is_state('binary_sensor.battery_peak_risk_now', 'on') %}

          {% set soc_limit = min(target_soc if target_soc > 0 else 100, max_soc) %}

          {{ enabled and allow_grid and (cheap_price or cheapest_hour)
             and soc < soc_limit
             and not peak_risk }}

      #########################################################################
      # binary_sensor.battery_should_discharge_now
      # Discharge when:
      #   - expensive price OR peak risk
      #   - SoC > reserve
      #########################################################################
      - name: "Battery – Should discharge now"
        unique_id: battery_should_discharge_now
        state: >
          {% set soc      = states('sensor.battery_state_of_capacity') | float(0) %}
          {% set reserve  = states('input_number.battery_reserve_threshold') | float(0) %}
          {% set expensive = is_state('binary_sensor.battery_in_expensive_price_window', 'on') %}
          {% set peak_risk = is_state('binary_sensor.battery_peak_risk_now', 'on') %}
          {% set enabled   = is_state('input_boolean.battery_automation_enabled', 'on') %}
          {{ enabled and soc > reserve and (expensive or peak_risk) }}

###############################################################################
# AUTOMATIONS – Charge / discharge orchestration
###############################################################################
automation:
  ###########################################################################
  # 1) Start grid charging in cheap hours (price or calendar)
  ###########################################################################
  - id: battery_start_grid_charge_in_cheap_hours
    alias: "Battery – Start grid charging in cheap hours"
    mode: single
    description: >
      Uses Nordpool low-price threshold and cheapest-hours calendar
      to start a forcible charge-up towards the target SoC, respecting
      peak limit and reserve.

    trigger:
      - platform: state
        entity_id:
          - binary_sensor.battery_can_grid_charge_now
          - binary_sensor.electricity_cheapest_now
      - platform: state
        entity_id: sensor.nordpool_kwh_se3_sek_2_095_025

    condition:
      - condition: state
        entity_id: binary_sensor.battery_can_grid_charge_now
        state: "on"

    action:
      - variables:
          current_soc: "{{ states('sensor.battery_state_of_capacity') | float(0) }}"
          target_soc: >
            {% set t = states('input_number.battery_cheapest_hours_target_soc') | float(0) %}
            {% set max_grid = states('input_number.battery_max_grid_charge_soc') | float(100) %}
            {% set reserve = states('input_number.battery_reserve_threshold') | float(0) %}
            {% set soc_limit = [t if t > 0 else 100, max_grid] | min %}
            {{ [soc_limit, reserve] | max }}
          max_grid_power_kw: "{{ states('input_number.battery_max_grid_charge_power_kw') | float(2.0) }}"

      # Enable grid charging switch
      - service: switch.turn_on
        target:
          entity_id: switch.battery_charge_from_grid

      # Optional: set max grid charge power (if you want to use the number entity)
      # Uncomment and adjust if needed:
      # - service: number.set_value
      #   target:
      #     entity_id: number.battery_grid_charge_maximum_power
      #   data:
      #     value: "{{ (max_grid_power_kw * 1000) | int }}"

      # Forcible charge until target SoC (Huawei Solar service)
      - service: huawei_solar.forcible_charge_soc
        data:
          # TODO: adjust entity_id to the correct one for your inverter/battery
          entity_id: sensor.inverter_input_power
          target_soc: "{{ target_soc | round(0) }}"

  ###########################################################################
  # 2) Stop grid charging when SoC reached or conditions no longer valid
  ###########################################################################
  - id: battery_stop_grid_charge_when_done_or_not_cheap
    alias: "Battery – Stop grid charging when done / not cheap"
    mode: single
    description: >
      Stops forcible grid charging when target SoC is reached,
      cheap window ends or peak risk appears.

    trigger:
      - platform: state
        entity_id:
          - binary_sensor.battery_can_grid_charge_now
          - binary_sensor.electricity_cheapest_now
          - binary_sensor.battery_peak_risk_now
      - platform: state
        entity_id: sensor.battery_state_of_capacity

    condition: []

    action:
      - variables:
          soc: "{{ states('sensor.battery_state_of_capacity') | float(0) }}"
          reserve: "{{ states('input_number.battery_reserve_threshold') | float(0) }}"
          target_soc: >
            {% set t = states('input_number.battery_cheapest_hours_target_soc') | float(0) %}
            {% set max_grid = states('input_number.battery_max_grid_charge_soc') | float(100) %}
            {% if t > 0 %}
              {% set soc_limit = [t, max_grid] | min %}
            {% else %}
              {% set soc_limit = max_grid %}
            {% endif %}
            {{ [soc_limit, reserve] | max }}
          cheap_now: "{{ is_state('binary_sensor.battery_in_cheap_price_window', 'on') }}"
          cheapest_hour: "{{ is_state('binary_sensor.electricity_cheapest_now', 'on') }}"
          peak_risk: "{{ is_state('binary_sensor.battery_peak_risk_now', 'on') }}"
          can_grid_charge: "{{ is_state('binary_sensor.battery_can_grid_charge_now', 'on') }}"

      - choose:
          # Stop if SoC reached or passed target
          - conditions:
              - condition: template
                value_template: "{{ soc >= target_soc }}"
            sequence:
              - service: huawei_solar.stop_forcible_charge
                data: {}
              - service: switch.turn_off
                target:
                  entity_id: switch.battery_charge_from_grid

          # Stop if not cheap anymore, no cheapest-hour and peak risk present
          - conditions:
              - condition: template
                value_template: >
                  {{ (not cheap_now and not cheapest_hour) or peak_risk or not can_grid_charge }}
            sequence:
              - service: huawei_solar.stop_forcible_charge
                data: {}
              - service: switch.turn_off
                target:
                  entity_id: switch.battery_charge_from_grid

      # default: no-op

  ###########################################################################
  # 3) Discharge for peak shaving / expensive price
  ###########################################################################
  - id: battery_discharge_for_peak_and_high_price
    alias: "Battery – Discharge for peak shaving / high price"
    mode: single
    description: >
      Uses Huawei forcible_discharge_soc to support peak shaving
      and high price periods, while preserving reserve SoC.

    trigger:
      - platform: state
        entity_id:
          - binary_sensor.battery_should_discharge_now
          - binary_sensor.battery_peak_risk_now
          - binary_sensor.battery_in_expensive_price_window
      - platform: state
        entity_id: sensor.total_power_usage
      - platform: state
        entity_id: sensor.nordpool_kwh_se3_sek_2_095_025

    condition:
      - condition: state
        entity_id: input_boolean.battery_peak_helper_enabled
        state: "on"
      - condition: state
        entity_id: binary_sensor.battery_should_discharge_now
        state: "on"

    action:
      - variables:
          reserve: "{{ states('input_number.battery_reserve_threshold') | float(0) }}"
          soc: "{{ states('sensor.battery_state_of_capacity') | float(0) }}"

      # Do not discharge below reserve, just ensure we head towards reserve
      - service: huawei_solar.forcible_discharge_soc
        data:
          # TODO: adjust entity_id to match your inverter/battery entity
          entity_id: sensor.inverter_input_power
          target_soc: "{{ reserve | round(0) }}"

  ###########################################################################
  # 4) Stop forcible discharge when conditions clear or SoC near reserve
  ###########################################################################
  - id: battery_stop_discharge_when_safe
    alias: "Battery – Stop forcible discharge when safe"
    mode: single
    description: >
      Stops forcible discharge once peak risk and high price pass,
      or when SoC is at or just above reserve.

    trigger:
      - platform: state
        entity_id:
          - binary_sensor.battery_should_discharge_now
          - binary_sensor.battery_peak_risk_now
          - binary_sensor.battery_in_expensive_price_window
      - platform: state
        entity_id: sensor.battery_state_of_capacity

    condition: []

    action:
      - variables:
          reserve: "{{ states('input_number.battery_reserve_threshold') | float(0) }}"
          soc: "{{ states('sensor.battery_state_of_capacity') | float(0) }}"
          should_discharge: "{{ is_state('binary_sensor.battery_should_discharge_now', 'on') }}"
          peak_risk: "{{ is_state('binary_sensor.battery_peak_risk_now', 'on') }}"
          expensive: "{{ is_state('binary_sensor.battery_in_expensive_price_window', 'on') }}"

      - choose:
          # Stop when SoC <= reserve or no more reason to discharge
          - conditions:
              - condition: template
                value_template: >
                  {{ soc <= reserve or (not should_discharge and not peak_risk and not expensive) }}
            sequence:
              - service: huawei_solar.stop_forcible_charge
                data: {}
              # Note: forcible_discharge and forcible_charge share stop service
      # default: no-op
